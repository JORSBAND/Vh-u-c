<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>S23 Depth Mesh</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: monospace; color: cyan; }
        
        #debug-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 999;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid cyan;
            pointer-events: none;
        }

        .info { font-size: 14px; margin-bottom: 5px; }
        .error { color: red; font-weight: bold; }
        .success { color: lime; font-weight: bold; }
    </style>
</head>
<body>

    <div id="debug-overlay">
        <div class="info">S23 Depth Visualizer v2.0</div>
        <div id="ar-status" class="info">Статус: Очікування запуску...</div>
        <div id="depth-status" class="info">Дані глибини: ---</div>
        <div id="distance" class="info">Відстань по центру: ---</div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';

        let camera, scene, renderer;
        let depthMesh, cursorMesh;
        
        const arStatus = document.getElementById('ar-status');
        const depthStatus = document.getElementById('depth-status');
        const distDisplay = document.getElementById('distance');

        // Розміри сітки (чим більше, тим детальніше, але повільніше)
        const SEGMENTS_X = 60;
        const SEGMENTS_Y = 40;

        init();
        animate();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // 1. СТВОРЮЄМО СІТКУ (Wireframe Grid)
            // Це буде наша "тканина", яку ми накинемо на кімнату
            const geometry = new THREE.PlaneGeometry(4, 3, SEGMENTS_X, SEGMENTS_Y);
            
            // Повертаємо сітку, щоб вона дивилася на нас (за замовчуванням Plane лежить)
            // Але в AR ми будемо прив'язувати вершини до екрану, тому це не критично,
            // проте для старту відсунемо її.
            geometry.translate(0, 0, -2); // Відсунути на 2 метри вперед

            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });

            depthMesh = new THREE.Mesh(geometry, material);
            // Додаємо mesh до камери, а не до сцени! 
            // Це важливо: сітка завжди має бути перед очима, як HUD в шоломі залізної людини.
            // Але WebXR Depth API дає координати в world space, тому краще до сцени, але оновлювати щокадру.
            // Для спрощення ми додамо в сцену і будемо рухати вершини.
            scene.add(depthMesh);

            // 2. КУРСОР (Щоб бачити, що 3D взагалі працює)
            const cursorGeo = new THREE.RingGeometry(0.02, 0.04, 32);
            const cursorMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
            cursorMesh.position.z = -1; // 1 метр перед камерою
            camera.add(cursorMesh); // Прикріпити до камери
            scene.add(camera);

            // 3. КНОПКА AR
            const button = ARButton.createButton(renderer, {
                requiredFeatures: ['depth-sensing', 'dom-overlay'],
                domOverlay: { root: document.body },
                depthSensing: {
                    usagePreference: ["cpu-optimized"],
                    dataFormatPreference: ["luminance-alpha"]
                }
            });
            document.body.appendChild(button);

            // Події
            renderer.xr.addEventListener('sessionstart', () => {
                arStatus.innerText = "AR Сесія: АКТИВНА";
                arStatus.className = "success";
            });
            
            renderer.xr.addEventListener('sessionend', () => {
                arStatus.innerText = "AR Сесія: ЗАВЕРШЕНА";
                arStatus.className = "info";
            });

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            // Оновлюємо курсор (проста анімація пульсації)
            if(cursorMesh) {
                const scale = 1 + Math.sin(timestamp / 200) * 0.2;
                cursorMesh.scale.set(scale, scale, scale);
            }

            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();
                const viewerPose = frame.getViewerPose(referenceSpace);

                if (viewerPose) {
                    const view = viewerPose.views[0];
                    const depthInfo = frame.getDepthInformation(view);

                    if (depthInfo) {
                        depthStatus.innerText = `Дані глибини: ОТРИМАНО (${depthInfo.width}x${depthInfo.height})`;
                        depthStatus.className = "success";
                        
                        updateGrid(depthInfo, view, referenceSpace);
                    } else {
                        depthStatus.innerText = "Дані глибини: НЕМАЄ (null)";
                        depthStatus.className = "error";
                    }
                }
            }
            
            renderer.render(scene, camera);
        }

        // Найголовніша функція
        function updateGrid(depthInfo, view, referenceSpace) {
            const positions = depthMesh.geometry.attributes.position;
            
            // Нам потрібно знати позицію та орієнтацію камери в просторі
            // Щоб правильно розмістити точки
            const cameraPosition = new THREE.Vector3();
            const cameraQuaternion = new THREE.Quaternion();
            const transform = view.transform;
            
            cameraPosition.set(transform.position.x, transform.position.y, transform.position.z);
            cameraQuaternion.set(transform.orientation.x, transform.orientation.y, transform.orientation.z, transform.orientation.w);

            // Проходимося по вершинах нашої сітки
            for (let i = 0; i < positions.count; i++) {
                // Отримуємо нормалізовані координати сітки (від 0 до 1)
                // Сітка має розміри SEGMENTS_X на SEGMENTS_Y
                const ix = i % (SEGMENTS_X + 1);
                const iy = Math.floor(i / (SEGMENTS_X + 1));
                
                const u = ix / SEGMENTS_X;
                const v = iy / SEGMENTS_Y; 
                // Важливо: v може потребувати інверсії (1 - v) залежно від орієнтації екрану

                // Отримуємо глибину в цій точці (0 = на носі, >0 = метри)
                // getDepthInMeters(x, y) - x і y від 0.0 до 1.0
                const depth = depthInfo.getDepthInMeters(u, v);

                // Якщо глибина валідна
                if (depth > 0.1 && depth < 8.0) {
                    // Конвертуємо 2D точку екрану + Глибину -> в 3D точку простору
                    // Це спрощена математика проекції
                    
                    // Позиція на екрані (-1 до 1)
                    const xNDC = (u - 0.5) * 2;
                    const yNDC = (1 - v - 0.5) * 2; // Інвертуємо Y для WebGL

                    // Вектор направлення від камери
                    const vec = new THREE.Vector3(xNDC, yNDC, 0.5); // 0.5 - довільна z в NDC
                    vec.unproject(camera); // Перетворюємо в світові координати
                    vec.sub(cameraPosition).normalize(); // Вектор напрямку від камери
                    
                    // Фінальна позиція = Позиція Камери + (Напрямок * Дистанцію)
                    const finalPos = vec.multiplyScalar(depth).applyQuaternion(cameraQuaternion).add(cameraPosition);
                    
                    // В AR ми часто працюємо в Local Space, тому трохи простіше:
                    // Просто ставимо точку перед камерою
                    // Але для демо зробимо "екранний ефект"
                    
                    // Простіший метод для візуалізації (Local Space камери):
                    // X = (u-0.5) * depth * FOV_FACTOR
                    // Y = (v-0.5) * depth * FOV_FACTOR
                    // Z = -depth
                    
                    // Спробуємо цей метод, він стабільніший для "HUD" ефекту
                    const fovFactor = 1.5; // Емпіричний коефіцієнт для S23
                    
                    const localX = (u - 0.5) * depth * 2.0; 
                    const localY = (1 - v - 0.5) * depth * 2.0 * (window.innerHeight/window.innerWidth); // Aspect fix
                    const localZ = -depth;

                    // Тепер треба перевести localX/Y/Z в світові координати, бо mesh в сцені
                    const localVec = new THREE.Vector3(localX, localY, localZ);
                    localVec.applyQuaternion(cameraQuaternion);
                    localVec.add(cameraPosition);

                    positions.setXYZ(i, localVec.x, localVec.y, localVec.z);
                    
                    // Виведемо дистанцію по центру екрану
                    if (Math.abs(u - 0.5) < 0.05 && Math.abs(v - 0.5) < 0.05) {
                        distDisplay.innerText = `Відстань: ${depth.toFixed(2)}м`;
                    }

                } else {
                    // Якщо даних немає - ховаємо точку далеко
                    positions.setXYZ(i, 0, 0, 0); 
                }
            }
            
            positions.needsUpdate = true;
        }

    </script>
</body>
</html>


